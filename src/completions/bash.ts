import type { CommandData } from "./types";

/**
 * Generates a bash completion script for a command tree.
 *
 * Uses `complete -F` with a function that handles subcommand routing
 * via case statements and completes options with COMPREPLY.
 */
export function generateBashCompletions(data: CommandData): string {
  const lines: string[] = [];
  const funcName = `_${sanitizeName(data.name)}_completions`;

  lines.push(`# Bash completions for ${data.name}`);
  lines.push(`# Generated by @truyman/cli`);
  lines.push(`# Add to ~/.bashrc: eval "$(${data.name} completions bash)"`);
  lines.push("");
  lines.push(`${funcName}() {`);
  lines.push(`  local cur prev words cword`);
  lines.push(`  _init_completion || return`);
  lines.push("");
  lines.push(`  local commands="${getSubcommandNames(data).join(" ")}"`);
  lines.push(`  local global_opts="${formatOptions(data.options)}"`);
  lines.push("");

  // Generate subcommand completions
  lines.push(...generateSubcommandCases(data, 1));

  lines.push("");
  lines.push(`  # Complete top-level commands or options`);
  lines.push(`  if [[ "\${cur}" == -* ]]; then`);
  lines.push(`    COMPREPLY=( $(compgen -W "\${global_opts}" -- "\${cur}") )`);
  lines.push(`  else`);
  lines.push(`    COMPREPLY=( $(compgen -W "\${commands}" -- "\${cur}") )`);
  lines.push(`  fi`);
  lines.push(`}`);
  lines.push("");
  lines.push(`complete -F ${funcName} ${data.name}`);

  return lines.join("\n");
}

function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, "_");
}

function getSubcommandNames(data: CommandData): string[] {
  return data.subcommands.filter((sub) => !sub.hidden).map((sub) => sub.name);
}

function formatOptions(options: CommandData["options"]): string {
  const opts: string[] = ["--help", "-h"];
  for (const opt of options) {
    opts.push(`--${opt.long}`);
    if (opt.short) {
      opts.push(`-${opt.short}`);
    }
  }
  return opts.join(" ");
}

function generateSubcommandCases(data: CommandData, depth: number): string[] {
  const lines: string[] = [];
  const visibleSubcommands = data.subcommands.filter((sub) => !sub.hidden);

  if (visibleSubcommands.length === 0) {
    return lines;
  }

  const indent = "  ".repeat(depth);
  lines.push(`${indent}# Handle subcommands at depth ${depth}`);
  lines.push(`${indent}case "\${words[${depth}]}" in`);

  for (const sub of visibleSubcommands) {
    lines.push(`${indent}  ${sub.name})`);

    const subOpts = formatOptions(sub.options);
    const subCmds = getSubcommandNames(sub);

    if (sub.subcommands.length > 0) {
      // Nested subcommands
      lines.push(...generateSubcommandCases(sub, depth + 1).map((l) => `${indent}    ${l.trim()}`));
      lines.push(`${indent}    if [[ "\${cur}" == -* ]]; then`);
      lines.push(`${indent}      COMPREPLY=( $(compgen -W "${subOpts}" -- "\${cur}") )`);
      lines.push(`${indent}    else`);
      lines.push(`${indent}      COMPREPLY=( $(compgen -W "${subCmds.join(" ")}" -- "\${cur}") )`);
      lines.push(`${indent}    fi`);
    } else {
      // Leaf command
      lines.push(`${indent}    COMPREPLY=( $(compgen -W "${subOpts}" -- "\${cur}") )`);
    }
    lines.push(`${indent}    return`);
    lines.push(`${indent}    ;;`);
  }

  lines.push(`${indent}esac`);

  return lines;
}
