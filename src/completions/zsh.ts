import type { CommandData } from "./types";

/**
 * Generates a zsh completion script for a command tree.
 *
 * Uses `_arguments` for option handling and state machine
 * for nested subcommand routing.
 */
export function generateZshCompletions(data: CommandData): string {
  const lines: string[] = [];
  const funcName = `_${sanitizeName(data.name)}`;

  lines.push(`#compdef ${data.name}`);
  lines.push("");
  lines.push(`# Zsh completions for ${data.name}`);
  lines.push(`# Generated by @truyman/cli`);
  lines.push(`# Add to fpath and run: compinit`);
  lines.push("");

  // Generate the main completion function
  lines.push(`${funcName}() {`);
  lines.push(`  local context state state_descr line`);
  lines.push(`  typeset -A opt_args`);
  lines.push("");
  lines.push(...generateCommandFunction(data, 1));
  lines.push(`}`);
  lines.push("");

  // Generate subcommand functions
  for (const sub of getAllSubcommands(data)) {
    lines.push(`${funcName}_${sanitizeName(sub.name)}() {`);
    lines.push(...generateCommandFunction(sub, 1));
    lines.push(`}`);
    lines.push("");
  }

  lines.push(`${funcName} "$@"`);

  return lines.join("\n");
}

function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, "_");
}

function getAllSubcommands(data: CommandData): CommandData[] {
  const result: CommandData[] = [];
  for (const sub of data.subcommands) {
    if (!sub.hidden) {
      result.push(sub);
      result.push(...getAllSubcommands(sub));
    }
  }
  return result;
}

function formatOptionSpec(opt: CommandData["options"][number]): string {
  const desc = opt.description ? `[${escapeZsh(opt.description)}]` : "";
  const valueSpec = opt.type !== "boolean" ? ":value:" : "";

  if (opt.short) {
    return `{-${opt.short},--${opt.long}}${desc}${valueSpec}`;
  }
  return `--${opt.long}${desc}${valueSpec}`;
}

function escapeZsh(str: string): string {
  return str.replace(/'/g, "'\\''").replace(/\[/g, "\\[").replace(/\]/g, "\\]");
}

function generateCommandFunction(data: CommandData, indent: number): string[] {
  const lines: string[] = [];
  const pad = "  ".repeat(indent);
  const visibleSubcommands = data.subcommands.filter((sub) => !sub.hidden);

  // Build arguments spec
  const argSpecs: string[] = [`'(-h --help)'{-h,--help}'[Show help]'`];

  for (const opt of data.options) {
    argSpecs.push(`'${formatOptionSpec(opt)}'`);
  }

  if (visibleSubcommands.length > 0) {
    // Parent command with subcommands
    lines.push(`${pad}_arguments -C \\`);
    for (const spec of argSpecs) {
      lines.push(`${pad}  ${spec} \\`);
    }
    lines.push(`${pad}  '1: :->command' \\`);
    lines.push(`${pad}  '*::arg:->args'`);
    lines.push("");
    lines.push(`${pad}case "$state" in`);
    lines.push(`${pad}  command)`);
    lines.push(`${pad}    local -a commands`);
    lines.push(`${pad}    commands=(`);

    for (const sub of visibleSubcommands) {
      const desc = sub.description ? escapeZsh(sub.description) : sub.name;
      lines.push(`${pad}      '${sub.name}:${desc}'`);
      // Add aliases as additional completions
      if (sub.aliases) {
        for (const alias of sub.aliases) {
          lines.push(`${pad}      '${alias}:${desc}'`);
        }
      }
    }

    lines.push(`${pad}    )`);
    lines.push(`${pad}    _describe 'command' commands`);
    lines.push(`${pad}    ;;`);
    lines.push(`${pad}  args)`);
    lines.push(`${pad}    case "$words[1]" in`);

    for (const sub of visibleSubcommands) {
      // Match both primary name and aliases
      const names = [sub.name, ...(sub.aliases || [])];
      lines.push(`${pad}      ${names.join("|")})`);
      lines.push(`${pad}        _${sanitizeName(data.name)}_${sanitizeName(sub.name)}`);
      lines.push(`${pad}        ;;`);
    }

    lines.push(`${pad}    esac`);
    lines.push(`${pad}    ;;`);
    lines.push(`${pad}esac`);
  } else {
    // Leaf command
    lines.push(`${pad}_arguments \\`);
    for (let i = 0; i < argSpecs.length; i++) {
      const suffix = i < argSpecs.length - 1 ? " \\" : "";
      lines.push(`${pad}  ${argSpecs[i]}${suffix}`);
    }
  }

  return lines;
}
