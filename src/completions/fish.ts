import type { CommandData } from "./types";

/**
 * Generates a fish completion script for a command tree.
 *
 * Uses `complete -c` with conditions like `__fish_use_subcommand`
 * and `__fish_seen_subcommand_from` for context-aware completions.
 */
export function generateFishCompletions(data: CommandData): string {
  const lines: string[] = [];
  const cmdName = data.name;

  lines.push(`# Fish completions for ${cmdName}`);
  lines.push(`# Generated by @truyman/cli`);
  lines.push(`# Save to ~/.config/fish/completions/${cmdName}.fish`);
  lines.push("");

  // Disable file completions by default
  lines.push(`complete -c ${cmdName} -f`);
  lines.push("");

  // Generate completions recursively
  lines.push(...generateCommandCompletions(cmdName, data, []));

  return lines.join("\n");
}

function generateCommandCompletions(
  cmdName: string,
  data: CommandData,
  parentChain: string[],
): string[] {
  const lines: string[] = [];
  const visibleSubcommands = data.subcommands.filter((sub) => !sub.hidden);

  // Build condition for when this command's options/subcommands should be shown
  const condition = buildCondition(parentChain, visibleSubcommands);

  // Add global options (help is always available)
  lines.push(`# Options for: ${parentChain.length > 0 ? parentChain.join(" ") : cmdName}`);
  lines.push(`complete -c ${cmdName} ${condition} -s h -l help -d 'Show help'`);

  // Add command-specific options
  for (const opt of data.options) {
    const shortFlag = opt.short ? `-s ${opt.short} ` : "";
    const longFlag = `-l ${opt.long}`;
    const desc = opt.description ? ` -d '${escapeFish(opt.description)}'` : "";
    const requiresArg = opt.type !== "boolean" ? " -r" : "";
    lines.push(`complete -c ${cmdName} ${condition} ${shortFlag}${longFlag}${requiresArg}${desc}`);
  }

  // Add subcommands
  if (visibleSubcommands.length > 0) {
    lines.push("");
    lines.push(`# Subcommands for: ${parentChain.length > 0 ? parentChain.join(" ") : cmdName}`);

    for (const sub of visibleSubcommands) {
      const desc = sub.description ? ` -d '${escapeFish(sub.description)}'` : "";
      lines.push(`complete -c ${cmdName} ${condition} -a ${sub.name}${desc}`);
      // Add aliases as additional completions
      if (sub.aliases) {
        for (const alias of sub.aliases) {
          lines.push(`complete -c ${cmdName} ${condition} -a ${alias}${desc}`);
        }
      }
    }

    // Recurse for each subcommand
    for (const sub of visibleSubcommands) {
      lines.push("");
      lines.push(...generateCommandCompletions(cmdName, sub, [...parentChain, sub.name]));
    }
  }

  return lines;
}

function buildCondition(parentChain: string[], hasSubcommands: CommandData[]): string {
  if (parentChain.length === 0) {
    // Top-level: only show when no subcommand is selected
    if (hasSubcommands.length > 0) {
      return "-n __fish_use_subcommand";
    }
    return "";
  }

  // Nested: show when parent chain matches
  const conditions: string[] = [];

  // Must have seen the parent command(s)
  for (let i = 0; i < parentChain.length; i++) {
    const ancestor = parentChain[i];
    if (i === 0) {
      conditions.push(`__fish_seen_subcommand_from ${ancestor}`);
    }
  }

  // For the last parent, we need to check it's the current subcommand context
  if (parentChain.length > 0) {
    const lastParent = parentChain[parentChain.length - 1];
    if (hasSubcommands.length > 0) {
      // Has subcommands: show options when parent is seen but no nested subcommand yet
      // Include both names and aliases in the check
      const allNames: string[] = [];
      for (const s of hasSubcommands) {
        allNames.push(s.name);
        if (s.aliases) {
          allNames.push(...s.aliases);
        }
      }
      return `-n "__fish_seen_subcommand_from ${lastParent}; and not __fish_seen_subcommand_from ${allNames.join(" ")}"`;
    }
    // Leaf command: show options when parent is seen
    return `-n "__fish_seen_subcommand_from ${lastParent}"`;
  }

  return `-n "${conditions.join("; and ")}"`;
}

function escapeFish(str: string): string {
  return str.replace(/'/g, "\\'");
}
